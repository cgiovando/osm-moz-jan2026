<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mozambique Flood Mapping - Coordinated OSM Response</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/pmtiles@3.0.3/dist/pmtiles.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #eee; }

        .container { display: flex; height: 100vh; }

        .sidebar {
            width: 280px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        h1 { font-size: 1.4em; color: #4ecca3; margin-bottom: 5px; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 20px; line-height: 1.4; }

        .stat-card {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .stat-value { font-size: 1.8em; font-weight: bold; color: #4ecca3; }
        .stat-label { font-size: 0.8em; color: #888; }

        .section-title {
            font-size: 0.75em;
            text-transform: uppercase;
            color: #666;
            margin: 20px 0 10px;
            letter-spacing: 1px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #1a1a2e;
            border-radius: 6px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .layer-toggle:hover { background: #2a2a4a; }
        .layer-toggle.inactive { opacity: 0.4; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; }
        .layer-name { flex: 1; font-size: 0.9em; }
        .layer-count { font-size: 0.8em; color: #4ecca3; }

        .download-link {
            display: block;
            color: #4ecca3;
            text-decoration: none;
            font-size: 0.85em;
            padding: 5px 0;
        }
        .download-link:hover { text-decoration: underline; }

        .main-content { flex: 1; display: flex; flex-direction: column; }

        #timeline {
            background: #16213e;
            padding: 15px 20px;
            border-bottom: 1px solid #2a2a4a;
        }
        .timeline-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .timeline-title { font-weight: 600; }
        .timeline-hint { font-size: 0.8em; color: #666; }
        .selected-date { color: #4ecca3; font-weight: 600; }

        .chart-container { position: relative; height: 100px; }
        .y-axis { position: absolute; left: -45px; top: 0; bottom: 0; width: 40px; }
        .y-label { position: absolute; right: 5px; font-size: 9px; color: #555; transform: translateY(-50%); }
        .gridlines { position: absolute; left: 0; right: 0; top: 0; bottom: 0; pointer-events: none; }
        .gridline { position: absolute; left: 0; right: 0; border-top: 1px solid #2a2a4a; }
        .gridline.major { border-top-color: #3a3a5a; }

        .bar-chart { display: flex; align-items: flex-end; height: 100%; gap: 1px; width: 100%; position: relative; z-index: 1; }
        .bar {
            background: linear-gradient(to top, #4ecca3, #45b39d);
            flex: 1;
            min-width: 2px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 1px 1px 0 0;
        }
        .bar:hover { background: linear-gradient(to top, #5ddbaf, #4ecca3); }
        .bar.selected { background: linear-gradient(to top, #f39c12, #e67e22); }
        .bar.dimmed { opacity: 0.3; }
        .bar.day-start { border-left: 1px solid rgba(255,255,255,0.3); }

        .x-axis { position: relative; height: 20px; margin-top: 5px; }
        .x-label { font-size: 10px; color: #666; position: absolute; transform: translateX(-50%); white-space: nowrap; }

        /* Animation controls */
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 6px;
        }
        .play-btn, .clear-btn {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
        }
        .play-btn:hover, .clear-btn:hover { background: #5ddbaf; }
        .play-btn.playing { background: #e74c3c; }
        .clear-btn { background: #666; color: #eee; }
        .clear-btn:hover { background: #888; }
        .time-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: #2a2a4a;
            border-radius: 3px;
            outline: none;
        }
        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4ecca3;
            border-radius: 50%;
            cursor: pointer;
        }
        .current-time {
            font-size: 0.85em;
            color: #4ecca3;
            min-width: 140px;
            text-align: right;
        }

        #map { flex: 1; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            z-index: 1000;
        }

        .update-notice {
            margin-top: 15px;
            padding: 8px 10px;
            background: rgba(78, 204, 163, 0.1);
            border-left: 3px solid #4ecca3;
            font-size: 11px;
            color: #aaa;
        }

        .ai-disclaimer {
            margin-top: auto;
            padding-top: 15px;
            font-size: 10px;
            color: #666;
            text-align: center;
            border-top: 1px solid #2a2a4a;
        }
        .ai-disclaimer a { color: #4ecca3; text-decoration: none; }
        .ai-disclaimer a:hover { text-decoration: underline; }

        .maplibregl-popup-content {
            background: #16213e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.85em;
        }
        .maplibregl-popup-anchor-bottom .maplibregl-popup-tip { border-top-color: #16213e; }

        /* Expandable contributors section */
        .contributors-section {
            background: #1a1a2e;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .contributors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .contributors-header:hover { background: #2a2a4a; }
        .contributors-header .stat-value { font-size: 1.8em; font-weight: bold; color: #4ecca3; }
        .contributors-header .stat-label { font-size: 0.8em; color: #888; }
        .contributors-toggle { color: #4ecca3; font-size: 1.2em; transition: transform 0.3s; }
        .contributors-section.expanded .contributors-toggle { transform: rotate(180deg); }
        .contributors-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .contributors-section.expanded .contributors-list { max-height: 400px; overflow-y: auto; }
        .contributor-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            border-top: 1px solid #2a2a4a;
            font-size: 0.85em;
        }
        .contributor-rank { color: #666; width: 25px; }
        .contributor-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .contributor-count { color: #4ecca3; font-weight: 600; margin-left: 10px; }

        /* Basemap switcher */
        .basemap-control {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #16213e;
            border-radius: 6px;
            padding: 8px;
            z-index: 1000;
        }
        .basemap-control select {
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #2a2a4a;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            cursor: pointer;
        }
        .basemap-control select:focus { outline: none; border-color: #4ecca3; }

        /* Dynamic stats overlay */
        .stats-overlay {
            position: absolute;
            top: 10px;
            left: 50px;
            background: rgba(22, 33, 62, 0.9);
            border-radius: 8px;
            padding: 12px 16px;
            z-index: 1000;
            min-width: 220px;
        }
        .stats-overlay-date {
            font-size: 1.6em;
            font-weight: bold;
            color: #4ecca3;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a4a;
        }
        .stats-overlay-row {
            display: flex;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .stats-overlay-row:last-child { margin-bottom: 0; }
        .stats-overlay-count {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecca3;
            margin-right: 8px;
        }
        .stats-overlay-label {
            font-size: 1em;
            color: #ccc;
        }
        .stats-overlay-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        /* Overview map */
        .overview-map {
            position: absolute;
            bottom: 30px;
            right: 10px;
            width: 180px;
            height: 150px;
            background: #16213e;
            border: 2px solid #4ecca3;
            border-radius: 6px;
            z-index: 1000;
            overflow: hidden;
        }
        .overview-map canvas { border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Mozambique Flood Response</h1>
            <p class="subtitle">Coordinated OSM mapping in flood-affected areas in Mozambique - January 2026</p>

            <div class="stat-card">
                <div class="stat-value" id="total-features">-</div>
                <div class="stat-label">Features Mapped</div>
            </div>
            <div class="contributors-section" id="contributors-section">
                <div class="contributors-header" id="contributors-header">
                    <div>
                        <div class="stat-value" id="total-contributors">-</div>
                        <div class="stat-label">Contributors</div>
                    </div>
                    <span class="contributors-toggle">▼</span>
                </div>
                <div class="contributors-list" id="contributors-list"></div>
            </div>

            <div class="section-title">Feature Layers</div>
            <div class="layer-toggle" data-layer="building">
                <div class="color-dot" style="background: #e74c3c;"></div>
                <span class="layer-name">Buildings</span>
                <span class="layer-count" id="count-building">0</span>
            </div>
            <div class="layer-toggle inactive" data-layer="highway">
                <div class="color-dot" style="background: #3498db;"></div>
                <span class="layer-name">Highways</span>
                <span class="layer-count" id="count-highway">0</span>
            </div>
            <div class="layer-toggle inactive" data-layer="waterway">
                <div class="color-dot" style="background: #2ecc71;"></div>
                <span class="layer-name">Waterways</span>
                <span class="layer-count" id="count-waterway">0</span>
            </div>

            <div class="section-title">HOT Projects</div>
            <div class="layer-toggle" data-layer="hot-projects" id="hot-toggle">
                <div class="color-dot" style="background: #f39c12; border: 2px solid #f39c12;"></div>
                <span class="layer-name">Project Areas</span>
                <span class="layer-count" id="count-hot">0</span>
            </div>

            <div class="section-title">Download Data</div>
            <a href="mozambique_flood_mapping.geojson" download class="download-link">OSM Features (GeoJSON)</a>
            <a href="mozambique_flood_mapping.pmtiles" download class="download-link">OSM Features (PMTiles)</a>
            <a href="hot_projects.geojson" download class="download-link">HOT Projects (GeoJSON)</a>
            <a href="mozambique_mapping_stats.json" download class="download-link">Statistics (JSON)</a>

            <div class="update-notice">
                Data updated daily at 00:00 UTC
            </div>

            <div class="ai-disclaimer">
                Built with AI assistance (Claude) · <a href="https://github.com/cgiovando/osm-moz-jan2026" target="_blank">Source</a>
            </div>
        </div>

        <div class="main-content">
            <div id="timeline">
                <div class="timeline-header">
                    <span class="timeline-title">Edits Over Time</span>
                    <span class="timeline-hint">Click a bar to filter by date <span class="selected-date" id="selected-date-label"></span></span>
                </div>
                <div class="chart-container">
                    <div class="y-axis" id="y-axis"></div>
                    <div class="gridlines" id="gridlines"></div>
                    <div class="bar-chart" id="bar-chart"></div>
                </div>
                <div class="x-axis" id="x-axis"></div>
                <div class="animation-controls">
                    <button class="play-btn" id="play-btn">▶ Play</button>
                    <button class="clear-btn" id="clear-btn">Clear</button>
                    <input type="range" class="time-slider" id="time-slider" min="0" max="100" value="100">
                    <span class="current-time" id="current-time">All times</span>
                </div>
            </div>
            <div id="map">
                <div id="loading">Loading map data...</div>
                <div class="stats-overlay" id="stats-overlay">
                    <div class="stats-overlay-date" id="stats-overlay-date"></div>
                    <div id="stats-overlay-content"></div>
                </div>
                <div class="basemap-control">
                    <select id="basemap-select">
                        <option value="carto-dark">CARTO Dark</option>
                        <option value="carto-light">CARTO Light</option>
                        <option value="osm-humanitarian">OSM Humanitarian</option>
                        <option value="esri-satellite">ESRI Satellite</option>
                    </select>
                </div>
                <div class="overview-map" id="overview-map"></div>
            </div>
        </div>
    </div>

    <script>
        // Register PMTiles protocol with explicit URL handling
        const PMTILES_URL = new URL('mozambique_flood_mapping.pmtiles', window.location.href).href;
        const p = new pmtiles.PMTiles(PMTILES_URL);

        // Add the protocol
        const protocol = new pmtiles.Protocol();
        maplibregl.addProtocol('pmtiles', protocol.tile);

        // Pre-cache the header
        p.getHeader().then(h => console.log('PMTiles header:', h));

        // Initialize map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    'carto-dark': {
                        type: 'raster',
                        tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors © CARTO'
                    }
                },
                layers: [{
                    id: 'carto-dark',
                    type: 'raster',
                    source: 'carto-dark',
                    minzoom: 0,
                    maxzoom: 19
                }]
            },
            center: [33.5, -24.95],
            zoom: 10,
            hash: true // Enable URL hash with zoom/lat/lng
        });

        // Add navigation controls
        map.addControl(new maplibregl.NavigationControl(), 'top-left');

        // Basemap options
        const basemaps = {
            'carto-dark': {
                tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'],
                attribution: '© OpenStreetMap contributors © CARTO'
            },
            'carto-light': {
                tiles: ['https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}@2x.png'],
                attribution: '© OpenStreetMap contributors © CARTO'
            },
            'osm-humanitarian': {
                tiles: ['https://a.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png'],
                attribution: '© OpenStreetMap contributors, Humanitarian OpenStreetMap Team'
            },
            'esri-satellite': {
                tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                attribution: '© Esri, Maxar, Earthstar Geographics'
            }
        };

        // Basemap switcher
        document.getElementById('basemap-select').addEventListener('change', (e) => {
            const basemap = basemaps[e.target.value];
            if (basemap && map.getSource('carto-dark')) {
                map.getSource('carto-dark').setTiles(basemap.tiles);
            }
        });

        // Overview map (minimap showing Mozambique context)
        const overviewMap = new maplibregl.Map({
            container: 'overview-map',
            style: {
                version: 8,
                sources: {
                    'overview-base': {
                        type: 'raster',
                        tiles: ['https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
                        tileSize: 256
                    }
                },
                layers: [{
                    id: 'overview-base',
                    type: 'raster',
                    source: 'overview-base'
                }]
            },
            center: [34, -24.5],  // Southern Mozambique where the flood area is
            zoom: 4.5,  // Balanced zoom to show context and extent box
            interactive: false,
            attributionControl: false
        });

        // Track if overview map is ready
        let overviewMapReady = false;

        // Add extent box to overview map
        overviewMap.on('load', () => {
            // Add a box showing current main map extent
            overviewMap.addSource('extent-box', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[[0,0],[0,0],[0,0],[0,0],[0,0]]]
                    }
                }
            });

            overviewMap.addLayer({
                id: 'extent-box-fill',
                type: 'fill',
                source: 'extent-box',
                paint: {
                    'fill-color': '#e74c3c',
                    'fill-opacity': 0.35
                }
            });

            overviewMap.addLayer({
                id: 'extent-box-line',
                type: 'line',
                source: 'extent-box',
                paint: {
                    'line-color': '#e74c3c',
                    'line-width': 3
                }
            });

            overviewMapReady = true;
            console.log('Overview map ready');
            updateOverviewExtent();
        });

        function updateOverviewExtent() {
            if (!overviewMapReady) return;

            try {
                const bounds = map.getBounds();
                if (!bounds) return;

                const w = bounds.getWest();
                const s = bounds.getSouth();
                const e = bounds.getEast();
                const n = bounds.getNorth();

                const geojson = {
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[
                            [w, s],
                            [e, s],
                            [e, n],
                            [w, n],
                            [w, s]
                        ]]
                    }
                };

                const source = overviewMap.getSource('extent-box');
                if (source) {
                    source.setData(geojson);
                }
            } catch (err) {
                console.log('Overview extent update error:', err);
            }
        }

        // Update on main map move
        map.on('moveend', updateOverviewExtent);
        map.on('zoomend', updateOverviewExtent);
        map.on('load', () => {
            updateOverviewExtent();
            // Also update periodically to catch any missed updates
            setInterval(updateOverviewExtent, 1000);
        });

        // State
        let stats = null;
        let hotProjectsBounds = null;
        let activeTypes = { building: true, highway: false, waterway: false };
        let hotProjectsVisible = true;
        let allTimestamps = [];
        let currentTimeFilter = null;
        let isPlaying = false;
        let animationFrame = null;

        // Stats by feature type (computed from GeoJSON)
        let statsByType = { building: {}, highway: {}, waterway: {} };

        // Load stats
        let topContributors = [];
        fetch('mozambique_mapping_stats.json')
            .then(r => r.json())
            .then(data => {
                stats = data;
                document.getElementById('total-features').textContent = data.total_features.toLocaleString();
                document.getElementById('total-contributors').textContent = data.unique_contributors.toLocaleString();

                // Store top contributors (will be populated from GeoJSON if not in stats)
                topContributors = data.top_contributors || [];

                // Build timeline with hourly bars (more detailed view)
                const hourlyData = data.edits_by_hour || data.edits_by_date;
                buildTimeline(hourlyData, data.edits_by_date);

                // Setup time slider with hourly data for fine-grained animation
                setupTimeSlider(hourlyData);
            });

        // Function to populate contributors list (called after GeoJSON loads)
        function populateContributorsList() {
            const list = document.getElementById('contributors-list');
            if (topContributors.length > 0) {
                list.innerHTML = topContributors.map(([name, count], i) => `
                    <div class="contributor-row">
                        <span class="contributor-rank">${i + 1}.</span>
                        <span class="contributor-name">${name}</span>
                        <span class="contributor-count">${count.toLocaleString()}</span>
                    </div>
                `).join('');
            } else {
                list.innerHTML = '<div class="contributor-row"><span class="contributor-name">Loading...</span></div>';
            }
        }

        // Contributors expandable section toggle
        document.getElementById('contributors-header').addEventListener('click', () => {
            document.getElementById('contributors-section').classList.toggle('expanded');
        });

        // Clear button handler
        document.getElementById('clear-btn').addEventListener('click', clearAll);

        // Feature type colors and labels
        const featureTypeConfig = {
            building: { color: '#e74c3c', label: 'Buildings' },
            highway: { color: '#3498db', label: 'Highways' },
            waterway: { color: '#2ecc71', label: 'Waterways' }
        };

        // Helper to format date
        function formatDateDisplay(dateStr) {
            const [y, m, d] = dateStr.split('-');
            const monthName = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m)-1];
            return `${monthName} ${parseInt(d)}, ${y}`;
        }

        // Update the dynamic stats overlay on the map
        function updateStatsOverlay(timestamp) {
            const content = document.getElementById('stats-overlay-content');
            const dateDisplay = document.getElementById('stats-overlay-date');

            // Calculate counts for each active layer
            const counts = {};
            let hasFilter = false;

            Object.keys(activeTypes).forEach(type => {
                if (!activeTypes[type]) return;

                let count = 0;
                if (timestamp) {
                    // Count features up to this timestamp
                    hasFilter = true;
                    Object.entries(statsByType[type]).forEach(([ts, c]) => {
                        if (ts <= timestamp) count += c;
                    });
                } else if (currentTimeFilter) {
                    // Count features for selected date
                    hasFilter = true;
                    Object.entries(statsByType[type]).forEach(([ts, c]) => {
                        if (ts.startsWith(currentTimeFilter)) count += c;
                    });
                } else {
                    // Count all features
                    Object.values(statsByType[type]).forEach(c => count += c);
                }
                counts[type] = count;
            });

            // Build overlay HTML for feature counts
            let html = '';
            Object.keys(counts).forEach(type => {
                const config = featureTypeConfig[type];
                html += `
                    <div class="stats-overlay-row">
                        <span class="stats-overlay-dot" style="background: ${config.color};"></span>
                        <span class="stats-overlay-count">${counts[type].toLocaleString()}</span>
                        <span class="stats-overlay-label">${config.label}${hasFilter ? ' mapped' : ''}</span>
                    </div>
                `;
            });

            content.innerHTML = html || '<div class="stats-overlay-row"><span class="stats-overlay-label">No layers selected</span></div>';

            // Update date display based on filter state
            if (timestamp) {
                // Animation running - show date + hour
                const date = timestamp.slice(0, 10);
                const hour = timestamp.slice(11, 13);
                const [y, m, d] = date.split('-');
                const monthName = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m)-1];
                dateDisplay.textContent = `${monthName} ${parseInt(d)}, ${y} - ${hour}:00`;
            } else if (currentTimeFilter) {
                // Day manually selected - show that date
                dateDisplay.textContent = formatDateDisplay(currentTimeFilter);
            } else {
                // No filter - show date range from stats
                if (stats && stats.edits_by_date && stats.edits_by_date.length > 0) {
                    const firstDate = stats.edits_by_date[0][0];
                    const lastDate = stats.edits_by_date[stats.edits_by_date.length - 1][0];
                    const [y1, m1, d1] = firstDate.split('-');
                    const [y2, m2, d2] = lastDate.split('-');
                    const month1 = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m1)-1];
                    const month2 = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m2)-1];
                    dateDisplay.textContent = `${month1} ${parseInt(d1)} - ${month2} ${parseInt(d2)}, ${y2}`;
                } else {
                    dateDisplay.textContent = 'All dates';
                }
            }
        }

        // Update timeline based on currently active layers
        function updateTimelineForLayers() {
            // Combine stats from active layers
            const combinedStats = {};

            // Get all unique timestamps from all types
            const allTs = new Set([
                ...Object.keys(statsByType.building),
                ...Object.keys(statsByType.highway),
                ...Object.keys(statsByType.waterway)
            ]);

            allTs.forEach(ts => {
                let count = 0;
                if (activeTypes.building) count += statsByType.building[ts] || 0;
                if (activeTypes.highway) count += statsByType.highway[ts] || 0;
                if (activeTypes.waterway) count += statsByType.waterway[ts] || 0;
                if (count > 0) combinedStats[ts] = count;
            });

            // Convert to sorted array
            const hourlyData = Object.entries(combinedStats).sort((a, b) => a[0].localeCompare(b[0]));

            if (hourlyData.length > 0) {
                buildTimeline(hourlyData, null);
                setupTimeSlider(hourlyData);
            }
        }

        // Build timeline with hourly bars and day markers
        function buildTimeline(editsByHour, editsByDate) {
            const maxVal = Math.max(...editsByHour.map(d => d[1]));
            buildYAxis(maxVal);

            const chart = document.getElementById('bar-chart');
            chart.innerHTML = '';

            // Track day boundaries for markers
            let prevDate = null;

            editsByHour.forEach(([timestamp, count]) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(count / maxVal) * 100}%`;

                // Extract date part (YYYY-MM-DD) from timestamp (YYYY-MM-DDTHH)
                const date = timestamp.slice(0, 10);
                const hour = timestamp.slice(11, 13);
                bar.dataset.date = date;
                bar.dataset.hour = timestamp;

                // Mark day boundaries with a visual separator
                if (prevDate && date !== prevDate) {
                    bar.classList.add('day-start');
                }
                prevDate = date;

                // Format tooltip
                const [y, m, d] = date.split('-');
                const monthName = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m)-1];
                bar.title = `${monthName} ${parseInt(d)}, ${hour}:00 - ${count.toLocaleString()} edits`;

                bar.addEventListener('click', () => selectDate(date));
                chart.appendChild(bar);
            });

            // X-axis labels - show day labels
            const xAxis = document.getElementById('x-axis');
            xAxis.innerHTML = '';

            // Find unique dates and their positions
            const datePositions = [];
            let currentDate = null;
            editsByHour.forEach(([timestamp], idx) => {
                const date = timestamp.slice(0, 10);
                if (date !== currentDate) {
                    datePositions.push({ date, idx });
                    currentDate = date;
                }
            });

            // Create labels for each day
            datePositions.forEach(({ date, idx }) => {
                const label = document.createElement('span');
                label.className = 'x-label';
                const [y, m, d] = date.split('-');
                label.textContent = `${['Jan','Feb','Mar','Apr','May'][parseInt(m)-1]} ${parseInt(d)}`;
                // Position label based on where day starts
                label.style.position = 'absolute';
                label.style.left = `${(idx / editsByHour.length) * 100}%`;
                xAxis.appendChild(label);
            });
        }

        // Build Y-axis
        function buildYAxis(maxVal) {
            const yAxis = document.getElementById('y-axis');
            const gridlines = document.getElementById('gridlines');
            yAxis.innerHTML = '';
            gridlines.innerHTML = '';

            if (maxVal <= 0) return;

            const magnitude = Math.pow(10, Math.floor(Math.log10(maxVal)));
            const normalized = maxVal / magnitude;
            let interval = normalized <= 2 ? magnitude / 5 : normalized <= 5 ? magnitude / 2 : magnitude;
            while (maxVal / interval > 8) interval *= 2;

            for (let val = interval; val <= maxVal; val += interval) {
                const pct = (1 - val / maxVal) * 100;
                const isMajor = val % (interval * 2) === 0 || interval >= 5000;

                const label = document.createElement('div');
                label.className = 'y-label';
                label.style.top = `${pct}%`;
                label.textContent = val >= 1000 ? (val / 1000) + 'k' : val;
                yAxis.appendChild(label);

                const line = document.createElement('div');
                line.className = 'gridline' + (isMajor ? ' major' : '');
                line.style.top = `${pct}%`;
                gridlines.appendChild(line);
            }
        }

        // Select date (highlights all hourly bars for that date)
        function selectDate(date) {
            // Stop animation if playing
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
                document.getElementById('play-btn').classList.remove('playing');
                if (animationFrame) cancelAnimationFrame(animationFrame);
            }

            // Clear animation timestamp so date filter takes effect
            currentAnimationTimestamp = null;

            // Reset slider to end position
            const slider = document.getElementById('time-slider');
            slider.value = allTimestamps.length;
            document.getElementById('current-time').textContent = 'All times';

            // Reset flash colors back to normal
            if (map.getLayer('buildings-layer')) {
                map.setPaintProperty('buildings-layer', 'fill-color', '#ff6b6b');
            }
            if (map.getLayer('buildings-circles-layer')) {
                map.setPaintProperty('buildings-circles-layer', 'circle-color', '#ff6b6b');
                map.setPaintProperty('buildings-circles-layer', 'circle-radius', [
                    'interpolate', ['linear'], ['zoom'],
                    7, 0.5, 8, 0.6, 9, 0.8, 10, 1, 11, 1.25, 12, 1.5, 13, 2
                ]);
            }
            if (map.getLayer('highways-layer')) {
                map.setPaintProperty('highways-layer', 'line-color', '#3498db');
            }
            if (map.getLayer('waterways-layer')) {
                map.setPaintProperty('waterways-layer', 'line-color', '#2ecc71');
            }

            // Update bar highlights
            document.querySelectorAll('.bar').forEach(bar => {
                bar.classList.remove('selected', 'dimmed');
                if (date && bar.dataset.date !== date) bar.classList.add('dimmed');
                else if (bar.dataset.date === date) bar.classList.add('selected');
            });

            const label = document.getElementById('selected-date-label');
            if (date) {
                label.textContent = `(${date})`;
                filterByDate(date);
            } else {
                label.textContent = '';
                clearDateFilter();
            }
        }

        // Filter by date
        function filterByDate(date) {
            currentTimeFilter = date;
            updateMapFilter();
            updateStatsOverlay(null);
        }

        // Clear date filter
        function clearDateFilter() {
            currentTimeFilter = null;
            updateMapFilter();
        }

        // Update map based on time and layer toggles using opacity
        function updateMapFilter() {
            // If there's an animation timestamp active, use that
            if (currentAnimationTimestamp) {
                filterUpToTimestamp(currentAnimationTimestamp);
                return;
            }

            // Otherwise show all features based on layer toggles and date filter
            let opacityExpr;
            if (currentTimeFilter) {
                // Date-specific filter
                opacityExpr = [
                    'case',
                    ['all',
                        ['has', 'timestamp'],
                        ['==', ['slice', ['get', 'timestamp'], 0, 10], currentTimeFilter]
                    ],
                    1,
                    0
                ];
            } else {
                // Show all
                opacityExpr = 1;
            }

            // Update building layer
            if (map.getLayer('buildings-layer')) {
                const buildingOpacity = activeTypes.building ?
                    (typeof opacityExpr === 'number' ? 0.85 : ['*', 0.85, opacityExpr]) : 0;
                map.setPaintProperty('buildings-layer', 'fill-opacity', buildingOpacity);
            }
            if (map.getLayer('buildings-outline-layer')) {
                const outlineOpacity = activeTypes.building ?
                    (typeof opacityExpr === 'number' ? 0.9 : ['*', 0.9, opacityExpr]) : 0;
                map.setPaintProperty('buildings-outline-layer', 'line-opacity', outlineOpacity);
            }
            if (map.getLayer('buildings-circles-layer')) {
                const circleOpacity = activeTypes.building ?
                    (typeof opacityExpr === 'number' ? 0.9 : ['*', 0.9, opacityExpr]) : 0;
                map.setPaintProperty('buildings-circles-layer', 'circle-opacity', circleOpacity);
            }

            // Update highway layer
            if (map.getLayer('highways-layer')) {
                const highwayOpacity = activeTypes.highway ?
                    (typeof opacityExpr === 'number' ? 0.8 : ['*', 0.8, opacityExpr]) : 0;
                map.setPaintProperty('highways-layer', 'line-opacity', highwayOpacity);
            }

            // Update waterway layer
            if (map.getLayer('waterways-layer')) {
                const waterwayOpacity = activeTypes.waterway ?
                    (typeof opacityExpr === 'number' ? 0.8 : ['*', 0.8, opacityExpr]) : 0;
                map.setPaintProperty('waterways-layer', 'line-opacity', waterwayOpacity);
            }
        }

        // Setup time slider for animation (hourly granularity)
        function setupTimeSlider(editsByHour) {
            const slider = document.getElementById('time-slider');
            const timeDisplay = document.getElementById('current-time');
            const playBtn = document.getElementById('play-btn');

            // Create cumulative timestamps (hourly: YYYY-MM-DDTHH)
            allTimestamps = editsByHour.map(d => d[0]);
            slider.max = allTimestamps.length;
            slider.value = allTimestamps.length;

            slider.addEventListener('input', () => {
                const idx = parseInt(slider.value);
                if (idx >= allTimestamps.length) {
                    timeDisplay.textContent = 'All times';
                    clearTimeFilter();
                } else {
                    const ts = allTimestamps[idx];
                    timeDisplay.textContent = formatTimestamp(ts);
                    filterUpToTimestamp(ts);
                }
            });

            playBtn.addEventListener('click', toggleAnimation);
        }

        // Format timestamp for display
        function formatTimestamp(ts) {
            // ts format: YYYY-MM-DDTHH
            const date = ts.slice(0, 10);
            const hour = ts.slice(11, 13);
            const [y, m, d] = date.split('-');
            const monthName = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m)-1];
            return `${monthName} ${parseInt(d)}, ${hour}:00`;
        }

        // Filter up to timestamp (cumulative, hourly)
        // Uses opacity-based animation to avoid MapLibre tessellation artifacts
        function filterUpToTimestamp(ts) {
            currentAnimationTimestamp = ts;

            // Create opacity expression: 1 if timestamp <= ts, 0 otherwise
            const opacityExpression = [
                'case',
                ['all',
                    ['has', 'timestamp'],
                    ['<=', ['slice', ['get', 'timestamp'], 0, 13], ts]
                ],
                1, // visible
                0  // hidden
            ];

            // Expression for "new" features (matching current timestamp exactly)
            const isNewFeature = [
                'all',
                ['has', 'timestamp'],
                ['==', ['slice', ['get', 'timestamp'], 0, 13], ts]
            ];

            // Update building layer
            if (map.getLayer('buildings-layer')) {
                const buildingOpacity = activeTypes.building ?
                    ['*', 0.85, opacityExpression] : 0;
                map.setPaintProperty('buildings-layer', 'fill-opacity', buildingOpacity);
                // Flash new buildings with bright color
                map.setPaintProperty('buildings-layer', 'fill-color', [
                    'case', isNewFeature, '#ffff00', '#ff6b6b'
                ]);
            }
            if (map.getLayer('buildings-outline-layer')) {
                const outlineOpacity = activeTypes.building ?
                    ['*', 0.9, opacityExpression] : 0;
                map.setPaintProperty('buildings-outline-layer', 'line-opacity', outlineOpacity);
            }
            if (map.getLayer('buildings-circles-layer')) {
                const circleOpacity = activeTypes.building ?
                    ['*', 0.9, opacityExpression] : 0;
                map.setPaintProperty('buildings-circles-layer', 'circle-opacity', circleOpacity);
                // Flash new buildings with bright yellow and larger size
                map.setPaintProperty('buildings-circles-layer', 'circle-color', [
                    'case', isNewFeature, '#ffff00', '#ff6b6b'
                ]);
                map.setPaintProperty('buildings-circles-layer', 'circle-radius', [
                    'case', isNewFeature,
                    // Larger radius for new features
                    ['interpolate', ['linear'], ['zoom'],
                        7, 2, 8, 2.5, 9, 3, 10, 3.5, 11, 4, 12, 5, 13, 6
                    ],
                    // Normal radius
                    ['interpolate', ['linear'], ['zoom'],
                        7, 0.5, 8, 0.6, 9, 0.8, 10, 1, 11, 1.25, 12, 1.5, 13, 2
                    ]
                ]);
            }

            // Update highway layer
            if (map.getLayer('highways-layer')) {
                const highwayOpacity = activeTypes.highway ?
                    ['*', 0.8, opacityExpression] : 0;
                map.setPaintProperty('highways-layer', 'line-opacity', highwayOpacity);
                // Flash new highways
                map.setPaintProperty('highways-layer', 'line-color', [
                    'case', isNewFeature, '#ffff00', '#3498db'
                ]);
            }

            // Update waterway layer
            if (map.getLayer('waterways-layer')) {
                const waterwayOpacity = activeTypes.waterway ?
                    ['*', 0.8, opacityExpression] : 0;
                map.setPaintProperty('waterways-layer', 'line-opacity', waterwayOpacity);
                // Flash new waterways
                map.setPaintProperty('waterways-layer', 'line-color', [
                    'case', isNewFeature, '#ffff00', '#2ecc71'
                ]);
            }

            // Update stats overlay
            updateStatsOverlay(ts);
        }

        let currentAnimationTimestamp = null;

        // Clear all filters and selections
        function clearAll() {
            const slider = document.getElementById('time-slider');
            const timeDisplay = document.getElementById('current-time');

            // Stop animation if playing
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
                document.getElementById('play-btn').classList.remove('playing');
                if (animationFrame) cancelAnimationFrame(animationFrame);
            }

            // Reset slider
            slider.value = allTimestamps.length;
            timeDisplay.textContent = 'All times';

            // Clear bar chart selection
            document.querySelectorAll('.bar').forEach(bar => {
                bar.classList.remove('selected', 'dimmed');
            });
            document.getElementById('selected-date-label').textContent = '';

            // Clear map filters
            clearTimeFilter();
        }

        // Clear time filter
        function clearTimeFilter() {
            currentAnimationTimestamp = null;
            currentTimeFilter = null;

            // Reset colors back to normal (remove flash highlighting)
            if (map.getLayer('buildings-layer')) {
                map.setPaintProperty('buildings-layer', 'fill-color', '#ff6b6b');
            }
            if (map.getLayer('buildings-circles-layer')) {
                map.setPaintProperty('buildings-circles-layer', 'circle-color', '#ff6b6b');
                map.setPaintProperty('buildings-circles-layer', 'circle-radius', [
                    'interpolate', ['linear'], ['zoom'],
                    7, 0.5, 8, 0.6, 9, 0.8, 10, 1, 11, 1.25, 12, 1.5, 13, 2
                ]);
            }
            if (map.getLayer('highways-layer')) {
                map.setPaintProperty('highways-layer', 'line-color', '#3498db');
            }
            if (map.getLayer('waterways-layer')) {
                map.setPaintProperty('waterways-layer', 'line-color', '#2ecc71');
            }

            updateMapFilter();
            updateStatsOverlay(null);
        }

        // Toggle animation
        function toggleAnimation() {
            const playBtn = document.getElementById('play-btn');
            const slider = document.getElementById('time-slider');

            if (isPlaying) {
                isPlaying = false;
                playBtn.textContent = '▶ Play';
                playBtn.classList.remove('playing');
                if (animationFrame) cancelAnimationFrame(animationFrame);
            } else {
                isPlaying = true;
                playBtn.textContent = '⏸ Pause';
                playBtn.classList.add('playing');

                // Reset to start if at end
                if (parseInt(slider.value) >= allTimestamps.length) {
                    slider.value = 0;
                }

                animateTimeline();
            }
        }

        // Animate timeline
        function animateTimeline() {
            if (!isPlaying) return;

            const slider = document.getElementById('time-slider');
            const timeDisplay = document.getElementById('current-time');
            const idx = parseInt(slider.value);

            if (idx >= allTimestamps.length) {
                isPlaying = false;
                document.getElementById('play-btn').textContent = '▶ Play';
                document.getElementById('play-btn').classList.remove('playing');
                timeDisplay.textContent = 'All times';
                clearTimeFilter();
                return;
            }

            slider.value = idx + 1;
            const ts = allTimestamps[idx];
            timeDisplay.textContent = formatTimestamp(ts);
            filterUpToTimestamp(ts);

            // Highlight the corresponding hour's bar in the chart
            document.querySelectorAll('.bar').forEach(bar => {
                bar.classList.remove('selected', 'dimmed');
                const barHour = bar.dataset.hour;
                if (barHour === ts) {
                    bar.classList.add('selected');
                } else if (barHour > ts) {
                    bar.classList.add('dimmed');
                }
            });

            // Wait for map to finish rendering before next frame to prevent artifacts
            const scheduleNext = () => {
                if (!isPlaying) return;
                animationFrame = requestAnimationFrame(animateTimeline);
            };

            // Use idle event if map is still rendering, otherwise schedule with delay
            // Speed: 25ms normal, 10ms after idle (4x faster than original)
            if (map.isStyleLoaded() && !map.isMoving()) {
                setTimeout(scheduleNext, 25);
            } else {
                map.once('idle', () => {
                    setTimeout(scheduleNext, 10);
                });
            }
        }

        // Load map data when ready
        map.on('load', () => {
            document.getElementById('loading').style.display = 'none';

            // Try PMTiles first (works on GitHub Pages), fallback to GeoJSON for local dev
            loadOSMFeatures();
            loadHotProjects();

            // Update counts
            document.getElementById('count-building').textContent = '49,808';
            document.getElementById('count-highway').textContent = '1,025';
            document.getElementById('count-waterway').textContent = '3';
        });

        // Load OSM features - use pre-computed centroids for circles, GeoJSON/PMTiles for polygons
        async function loadOSMFeatures() {
            // Load data files in parallel for faster startup
            const [geojsonData, buildingCentroids] = await Promise.all([
                fetch('mozambique_flood_mapping.geojson').then(r => r.json()),
                fetch('building_centroids.geojson').then(r => r.json())
            ]);

            console.log(`Loaded ${buildingCentroids.features.length} pre-computed building centroids`);

            // Compute hourly stats by feature type for dynamic timeline
            // Also extract top contributors from user field
            statsByType = { building: {}, highway: {}, waterway: {} };
            const userCounts = {};
            geojsonData.features.forEach(f => {
                const props = f.properties;
                const ts = props.timestamp ? props.timestamp.slice(0, 13) : null; // YYYY-MM-DDTHH

                // Count by user
                const user = props.user;
                if (user) {
                    userCounts[user] = (userCounts[user] || 0) + 1;
                }

                if (!ts) return;

                if (props.building) {
                    statsByType.building[ts] = (statsByType.building[ts] || 0) + 1;
                }
                if (props.highway) {
                    statsByType.highway[ts] = (statsByType.highway[ts] || 0) + 1;
                }
                if (props.waterway) {
                    statsByType.waterway[ts] = (statsByType.waterway[ts] || 0) + 1;
                }
            });

            // Set top contributors (sorted by count, top 20)
            topContributors = Object.entries(userCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            populateContributorsList();

            console.log('Computed stats by feature type for dynamic timeline');
            console.log(`Found ${topContributors.length} top contributors`);

            // Update timeline with current layer selection
            updateTimelineForLayers();

            // Initialize stats overlay now that data is loaded
            updateStatsOverlay(null);

            // Source for building circles - simple points, no simplification possible
            map.addSource('building-centroids', {
                type: 'geojson',
                data: buildingCentroids
            });

            // Source for full geometries (polygons, lines)
            map.addSource('osm-features-geojson', {
                type: 'geojson',
                data: geojsonData,
                tolerance: 0.5 // Reduced simplification
            });

            // Try PMTiles for polygon layers (more efficient at high zoom)
            let usePMTiles = false;
            try {
                const testResponse = await fetch(PMTILES_URL, { method: 'HEAD' });
                const acceptRanges = testResponse.headers.get('Accept-Ranges');
                if (acceptRanges === 'bytes') {
                    map.addSource('osm-features-pmtiles', {
                        type: 'vector',
                        url: 'pmtiles://' + PMTILES_URL
                    });
                    usePMTiles = true;
                    console.log('Using PMTiles for polygon layers, GeoJSON for circles');
                }
            } catch (e) {
                console.log('PMTiles not available, using GeoJSON for all layers:', e.message);
            }

            addFeatureLayers(usePMTiles);
        }

        // Add feature layers
        function addFeatureLayers(usePMTiles) {
            // For polygon layers: use PMTiles if available (efficient), otherwise GeoJSON
            const polygonSource = usePMTiles ? 'osm-features-pmtiles' : 'osm-features-geojson';
            const polygonSourceLayerProp = usePMTiles ? { 'source-layer': 'osm_features' } : {};

            // For circle layer: always use GeoJSON (ensures ALL features visible at any zoom)
            const circleSource = 'osm-features-geojson';

            // Buildings layer (polygons) - only visible at zoom 14+
            map.addLayer({
                id: 'buildings-layer',
                type: 'fill',
                source: polygonSource,
                ...polygonSourceLayerProp,
                minzoom: 14, // Only show actual polygons at high zoom
                filter: ['has', 'building'],
                paint: {
                    'fill-color': '#ff6b6b',
                    'fill-opacity': 0.85,
                    'fill-outline-color': '#c0392b',
                    'fill-antialias': true
                }
            });

            // Buildings outline layer - only visible at zoom 14+
            map.addLayer({
                id: 'buildings-outline-layer',
                type: 'line',
                source: polygonSource,
                ...polygonSourceLayerProp,
                minzoom: 14, // Only show outlines at high zoom
                filter: ['has', 'building'],
                paint: {
                    'line-color': '#ff4444',
                    'line-width': 0.5,
                    'line-opacity': 0.9
                }
            });

            // Highways layer - use GeoJSON for consistency (off by default)
            map.addLayer({
                id: 'highways-layer',
                type: 'line',
                source: circleSource,
                filter: ['has', 'highway'],
                paint: {
                    'line-color': '#3498db',
                    'line-width': 2,
                    'line-opacity': 0 // Off by default
                }
            });

            // Waterways layer - use GeoJSON for consistency (off by default)
            map.addLayer({
                id: 'waterways-layer',
                type: 'line',
                source: circleSource,
                filter: ['has', 'waterway'],
                paint: {
                    'line-color': '#2ecc71',
                    'line-width': 3,
                    'line-opacity': 0 // Off by default
                }
            });

            // Buildings circle layer - uses pre-computed centroids (simple points)
            // This guarantees ALL 49,808 buildings visible at ANY zoom level
            map.addLayer({
                id: 'buildings-circles-layer',
                type: 'circle',
                source: 'building-centroids', // Use centroid points, not polygons
                maxzoom: 14, // Hide at zoom 14+ where polygons take over
                paint: {
                    'circle-color': '#ff6b6b',
                    'circle-radius': [
                        'interpolate', ['linear'], ['zoom'],
                        7, 0.5,
                        8, 0.6,
                        9, 0.8,
                        10, 1,
                        11, 1.25,
                        12, 1.5,
                        13, 2
                    ],
                    'circle-opacity': 0.9
                }
            });

            // Click handlers for popups
            map.on('click', 'buildings-layer', (e) => showPopup(e));
            map.on('click', 'buildings-circles-layer', (e) => showPopup(e));
            map.on('click', 'highways-layer', (e) => showPopup(e));
            map.on('click', 'waterways-layer', (e) => showPopup(e));

            // Cursor changes
            ['buildings-layer', 'buildings-circles-layer', 'highways-layer', 'waterways-layer'].forEach(layer => {
                map.on('mouseenter', layer, () => map.getCanvas().style.cursor = 'pointer');
                map.on('mouseleave', layer, () => map.getCanvas().style.cursor = '');
            });
        }

        // Show popup
        function showPopup(e) {
            const props = e.features[0].properties;
            const html = `
                <strong>OSM ${props.osm_type} #${props.osm_id}</strong><br>
                <strong>Mapped:</strong> ${props.timestamp}<br>
                <strong>By:</strong> ${props.user}<br>
                <strong>Changeset:</strong> <a href="https://www.openstreetmap.org/changeset/${props.changeset}" target="_blank">${props.changeset}</a>
            `;
            new maplibregl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(html)
                .addTo(map);
        }

        // Load HOT projects
        function loadHotProjects() {
            fetch('hot_projects.geojson')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('count-hot').textContent = data.features.length;

                    map.addSource('hot-projects', {
                        type: 'geojson',
                        data: data
                    });

                    map.addLayer({
                        id: 'hot-projects-layer',
                        type: 'line',
                        source: 'hot-projects',
                        paint: {
                            'line-color': '#f39c12',
                            'line-width': 3,
                            'line-dasharray': [2, 2],
                            'line-opacity': 0.9
                        }
                    });

                    map.addLayer({
                        id: 'hot-projects-fill',
                        type: 'fill',
                        source: 'hot-projects',
                        paint: {
                            'fill-color': '#f39c12',
                            'fill-opacity': 0.03
                        }
                    });

                    // Fit to bounds
                    const bounds = new maplibregl.LngLatBounds();
                    data.features.forEach(f => {
                        if (f.geometry.type === 'MultiPolygon') {
                            f.geometry.coordinates.forEach(poly => {
                                poly[0].forEach(coord => bounds.extend(coord));
                            });
                        } else if (f.geometry.type === 'Polygon') {
                            f.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
                        }
                    });
                    hotProjectsBounds = bounds;
                    map.fitBounds(bounds, { padding: 50 });

                    // Click handler for HOT projects
                    map.on('click', 'hot-projects-fill', (e) => {
                        const props = e.features[0].properties;
                        new maplibregl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(`
                                <strong>${props.name}</strong><br>
                                <strong>Project:</strong> <a href="${props.url}" target="_blank">#${props.projectId}</a><br>
                                <strong>Priority:</strong> ${props.priority}<br>
                                <strong>Progress:</strong> ${props.percentMapped}% mapped
                            `)
                            .addTo(map);
                    });
                });
        }

        // Layer toggle handlers
        document.querySelectorAll('.layer-toggle[data-layer]').forEach(toggle => {
            toggle.addEventListener('click', function() {
                const layer = this.dataset.layer;

                if (layer === 'hot-projects') {
                    hotProjectsVisible = !hotProjectsVisible;
                    this.classList.toggle('inactive', !hotProjectsVisible);
                    const visibility = hotProjectsVisible ? 'visible' : 'none';
                    if (map.getLayer('hot-projects-layer')) {
                        map.setLayoutProperty('hot-projects-layer', 'visibility', visibility);
                        map.setLayoutProperty('hot-projects-fill', 'visibility', visibility);
                    }
                } else {
                    activeTypes[layer] = !activeTypes[layer];
                    this.classList.toggle('inactive', !activeTypes[layer]);
                    updateMapFilter();
                    // Update timeline and stats overlay to reflect active layers
                    if (Object.keys(statsByType.building).length > 0) {
                        updateTimelineForLayers();
                        updateStatsOverlay(currentAnimationTimestamp);
                    }
                }
            });
        });

        // Zoom to extent button (add custom control)
        class ZoomExtentControl {
            onAdd(map) {
                this._map = map;
                this._container = document.createElement('div');
                this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group';
                this._container.innerHTML = '<button type="button" title="Zoom to full extent" style="font-size: 18px;">⌂</button>';
                this._container.querySelector('button').addEventListener('click', () => {
                    if (hotProjectsBounds) {
                        map.fitBounds(hotProjectsBounds, { padding: 50 });
                    }
                });
                return this._container;
            }
            onRemove() {
                this._container.parentNode.removeChild(this._container);
                this._map = undefined;
            }
        }
        map.addControl(new ZoomExtentControl(), 'top-left');
    </script>
</body>
</html>
